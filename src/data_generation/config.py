from __future__ import annotations

import json
import warnings
from collections import Counter
from collections.abc import Iterable, Mapping, Sequence
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Literal, Optional, Union

import yaml

SimulatorType = Literal["iqtree", "seqgen"]


class ConfigurationError(RuntimeError):
    """Raised when the configuration file cannot be parsed or validated."""


@dataclass(frozen=True)
class TopologySpec:
    tokens: tuple[tuple[str, ...], ...]
    root_index: Optional[int]

    def flatten(self) -> tuple[str, ...]:
        return tuple(taxon for group in self.tokens for taxon in group)

    def __iter__(self):
        return iter(self.tokens)

    def __len__(self) -> int:  # pragma: no cover - trivial proxy
        return len(self.tokens)


@dataclass
class TreeSettings:
    """User configurable options controlling tree generation."""

    taxa_labels: tuple[str, ...]
    rooted: bool = True
    topologies: tuple[TopologySpec, ...] = field(default_factory=tuple)
    branch_length_distributions: tuple[tuple[str, float], ...] = field(default_factory=tuple)
    branch_length_params: Mapping[str, Mapping[str, Any]] = field(default_factory=dict)
    split_root_branch: bool = True

    @property
    def taxa_count(self) -> int:
        return len(self.taxa_labels)

    @property
    def uniform_range(self) -> Optional[tuple[float, float]]:
        params = self.branch_length_params.get("uniform")
        if not params:
            return None
        rng = params.get("range")
        if not isinstance(rng, Iterable):  # pragma: no cover - defensive
            return None
        values = tuple(float(v) for v in rng)
        if len(values) != 2:  # pragma: no cover - defensive
            return None
        return values  # type: ignore[return-value]

    @property
    def exponential_rate(self) -> Optional[float]:
        params = self.branch_length_params.get("exponential")
        if not params:
            return None
        rate = params.get("rate")
        return float(rate) if rate is not None else None

    @property
    def truncated_exponential_params(self) -> Optional[tuple[float, float, float]]:
        """Return (rate, min, max) for truncated exponential; min defaults to 0 if not provided."""
        params = self.branch_length_params.get("truncated_exponential")
        if not params:
            return None
        rate = params.get("rate")
        lower = params.get("min", 0.0)
        upper = params.get("max")
        if rate is None or upper is None:
            return None
        return float(rate), float(lower), float(upper)

    @property
    def min_branch_length(self) -> float:
        rng = self.uniform_range
        if rng is None:
            return 0.0
        return rng[0]


@dataclass
class SequenceSettings:
    """Settings describing how sequences should be simulated."""

    length: int
    model: str = "JC"


@dataclass
class IndelSettings:
    """Configuration wrapper for indel behaviour."""

    enabled: bool = False
    rates: Optional[tuple[float, float]] = None


@dataclass
class SimulationSettings:
    """Settings describing how sequences are simulated for each tree."""

    backend: SimulatorType = "iqtree"
    iqtree_path: Optional[str] = None
    seqgen_path: Optional[str] = None
    seqgen_kwargs: dict[str, Any] = field(default_factory=dict)
    indel: IndelSettings = field(default_factory=IndelSettings)


@dataclass
class DatasetSettings:
    """Outputs generated by the tree/sequence generator."""

    tree_count: int
    output_basename: str
    root_directory: Path
    xml_directory: Optional[str] = None
    npy_directory: Optional[str] = None

    def ensure_xml_directory(self) -> None:
        self._xml_directory().mkdir(parents=True, exist_ok=True)
    
    def output_npy_path(self) -> Path:
        npy_dir = self._npy_directory()
        npy_dir.mkdir(parents=True, exist_ok=True)
        return npy_dir / f"{self.output_basename}.npy"

    def ensure_npy_directory(self) -> None:
        self._npy_directory().mkdir(parents=True, exist_ok=True)

    def xml_path(self) -> Path:
        return self._xml_directory() / f"{self.output_basename}.xml"

    def _xml_directory(self) -> Path:
        if self.xml_directory:
            return Path(self.xml_directory)
        return self.root_directory / "xml_data"

    def _npy_directory(self) -> Path:
        if self.npy_directory:
            return Path(self.npy_directory)
        return self.root_directory / "npy_data"


@dataclass
class GenerationConfig:
    """Aggregated configuration used across the data generation pipeline."""

    seed: int
    tree: TreeSettings
    sequence: SequenceSettings
    simulation: SimulationSettings
    dataset: DatasetSettings
    parallel_cores: int = 1

    @classmethod
    def from_mapping(cls, payload: Mapping[str, Any], base_path: Optional[Path] = None) -> "GenerationConfig":
        try:
            seed = int(payload["seed"])
        except KeyError as exc:  # pragma: no cover - defensive guard
            raise ConfigurationError("Configuration missing required key: 'seed'") from exc

        tree_payload = _expect_mapping(payload, "tree")
        taxa_labels = tuple(_expect_iterable(tree_payload, "taxa_labels"))
        if not taxa_labels:
            raise ConfigurationError("'tree.taxa_labels' must contain at least one label")

        rooted = bool(tree_payload.get("rooted", True))
        parsed_topologies = _parse_topologies(tree_payload.get("topologies"), taxa_labels, rooted=rooted)
        distributions_raw = tree_payload.get("branch_length_distributions")
        params_payload = tree_payload.get("branch_length_params")

        distributions_list: list[tuple[str, float]] = []
        parsed_params: dict[str, dict[str, Any]] = {}

        if distributions_raw is None or not isinstance(distributions_raw, Mapping):
            raise ConfigurationError("'tree.branch_length_distributions' must be a mapping of name to weight")

        total_weight = 0.0
        for name_raw, weight_raw in distributions_raw.items():
            try:
                name = str(name_raw).strip().lower()
            except Exception as exc:
                raise ConfigurationError("Distribution names must be strings") from exc
            try:
                weight = float(weight_raw)
            except Exception as exc:
                raise ConfigurationError("Distribution weights must be numbers") from exc
            if weight <= 0:
                raise ConfigurationError("Distribution weights must be positive")
            distributions_list.append((name, weight))
            total_weight += weight

        if not distributions_list:
            raise ConfigurationError("'tree.branch_length_distributions' must contain at least one entry")
        if abs(total_weight - 1.0) > 1e-6:
            raise ConfigurationError("Branch length distribution weights must sum to 1")

        if params_payload is None or not isinstance(params_payload, Mapping):
            raise ConfigurationError("'tree.branch_length_params' must be provided as a mapping")

        for dist_name, _ in distributions_list:
            dist_params_raw = params_payload.get(dist_name)
            if not isinstance(dist_params_raw, Mapping):
                raise ConfigurationError(f"Missing or invalid params for distribution '{dist_name}'")
            parsed_params[dist_name] = dict(dist_params_raw)

        # Validate known distributions
        for dist_name, _ in distributions_list:
            if dist_name == "uniform":
                raw_range = parsed_params[dist_name].get("range")
                if not isinstance(raw_range, Iterable):
                    raise ConfigurationError("'uniform' distribution requires a 'range' iterable of two numbers")
                values = tuple(float(v) for v in raw_range)
                if len(values) != 2:
                    raise ConfigurationError("'uniform' distribution range must have exactly two values")
                min_branch, max_branch = values
                if min_branch < 0 or max_branch <= 0 or max_branch <= min_branch:
                    raise ConfigurationError("Invalid 'uniform' distribution range values")
                parsed_params[dist_name]["range"] = (min_branch, max_branch)
            elif dist_name == "exponential":
                rate_raw = parsed_params[dist_name].get("rate")
                try:
                    rate = float(rate_raw)
                except Exception as exc:
                    raise ConfigurationError("'exponential' distribution requires numeric 'rate'") from exc
                if rate <= 0:
                    raise ConfigurationError("'exponential' distribution 'rate' must be positive")
                parsed_params[dist_name]["rate"] = rate
            elif dist_name == "truncated_exponential":
                rate_raw = parsed_params[dist_name].get("rate")
                max_raw = parsed_params[dist_name].get("max")
                min_raw = parsed_params[dist_name].get("min")
                try:
                    rate = float(rate_raw)
                    max_value = float(max_raw)
                    min_value = float(min_raw) if min_raw is not None else 0.0
                except Exception as exc:
                    raise ConfigurationError("'truncated_exponential' requires numeric 'rate', 'max', and optional 'min' (defaults to 0)") from exc
                if rate <= 0 or max_value <= 0:
                    raise ConfigurationError("'truncated_exponential' requires positive 'rate' and 'max'")
                if min_value < 0 or min_value >= max_value:
                    raise ConfigurationError("'truncated_exponential' 'min' must be >= 0 and < 'max'")
                parsed_params[dist_name]["rate"] = rate
                parsed_params[dist_name]["min"] = min_value
                parsed_params[dist_name]["max"] = max_value
            else:
                raise ConfigurationError(f"Unsupported branch length distribution '{dist_name}'")
        split_root_branch = bool(tree_payload.get("split_root_branch", True))
        tree_settings = TreeSettings(
            taxa_labels=taxa_labels,
            rooted=rooted,
            topologies=parsed_topologies,
            branch_length_distributions=tuple(distributions_list),
            branch_length_params=parsed_params,
            split_root_branch=split_root_branch,
        )

        sequence_payload = _expect_mapping(payload, "sequence")
        seq_length = int(sequence_payload.get("length", 1000))
        if seq_length <= 0:
            raise ConfigurationError("'sequence.length' must be positive")
        sequence_model = str(sequence_payload.get("model", "JC"))
        sequence_settings = SequenceSettings(length=seq_length, model=sequence_model)

        simulation_payload = _expect_mapping(payload, "simulation")
        backend_raw = simulation_payload.get("backend", "iqtree")
        if backend_raw not in ("iqtree", "seqgen"):
            raise ConfigurationError("'simulation.backend' must be either 'iqtree' or 'seqgen'")
        iqtree_path = simulation_payload.get("iqtree_path")
        seqgen_path = simulation_payload.get("seqgen_path")
        seqgen_kwargs = dict(simulation_payload.get("seqgen_kwargs", {}))

        indel_payload = simulation_payload.get("indel", {}) or {}
        if not isinstance(indel_payload, Mapping):
            raise ConfigurationError("'simulation.indel' must be a mapping when provided")
        indel_enabled = bool(indel_payload.get("enabled", False))
        rates_payload = indel_payload.get("rates")
        rates_tuple: Optional[tuple[float, float]]
        if rates_payload is None:
            rates_tuple = None
        else:
            if not isinstance(rates_payload, Iterable):
                raise ConfigurationError("'simulation.indel.rates' must be an iterable of two floats")
            candidate_rates = tuple(float(value) for value in rates_payload)
            if len(candidate_rates) != 2:
                raise ConfigurationError("'simulation.indel.rates' must contain exactly two values")
            rates_tuple = candidate_rates
        indel_settings = IndelSettings(enabled=indel_enabled, rates=rates_tuple)

        simulation_settings = SimulationSettings(
            backend=backend_raw,
            iqtree_path=str(iqtree_path) if iqtree_path else None,
            seqgen_path=str(seqgen_path) if seqgen_path else None,
            seqgen_kwargs=seqgen_kwargs,
            indel=indel_settings,
        )

        dataset_payload = _expect_mapping(payload, "dataset")
        tree_count = int(dataset_payload.get("tree_count", 1))
        if tree_count <= 0:
            raise ConfigurationError("'dataset.tree_count' must be positive")
        output_name_raw = dataset_payload.get("output_name")
        if output_name_raw is not None:
            candidate_name = str(output_name_raw).strip()
            candidate_path = Path(candidate_name)
            output_basename = candidate_path.stem or candidate_path.name
        else:
            legacy_raw = dataset_payload.get("output_xml", "generated_dataset")
            legacy_path = Path(str(legacy_raw).strip())
            output_basename = legacy_path.stem or legacy_path.name

        output_basename = output_basename.strip()
        if not output_basename:
            raise ConfigurationError("'dataset.output_name' must be a non-empty string")
        root_directory = _resolve_data_root(base_path)
        
        xml_directory = dataset_payload.get("xml_directory")
        if xml_directory is not None:
            xml_directory = str(xml_directory).strip()
            if not xml_directory:
                raise ConfigurationError("'dataset.xml_directory' must be a non-empty string")
        
        npy_directory = dataset_payload.get("npy_directory")
        if npy_directory is not None:
            npy_directory = str(npy_directory).strip()
            if not npy_directory:
                raise ConfigurationError("'dataset.npy_directory' must be a non-empty string")
        
        dataset_settings = DatasetSettings(
            tree_count=tree_count,
            output_basename=output_basename,
            root_directory=root_directory,
            xml_directory=xml_directory,
            npy_directory=npy_directory,
        )

        parallel_raw = payload.get("parallel_cores", 1)
        try:
            parallel_cores = int(parallel_raw)
        except (TypeError, ValueError) as exc:
            raise ConfigurationError("'parallel_cores' must be an integer") from exc
        if parallel_cores <= 0:
            raise ConfigurationError("'parallel_cores' must be a positive integer")

        return GenerationConfig(
            seed=seed,
            tree=tree_settings,
            sequence=sequence_settings,
            simulation=simulation_settings,
            dataset=dataset_settings,
            parallel_cores=parallel_cores,
        )

    def with_seed(self, seed: int) -> "GenerationConfig":
        """Return a shallow copy of this configuration with a new seed."""

        return GenerationConfig(
            seed=seed,
            tree=self.tree,
            sequence=self.sequence,
            simulation=self.simulation,
            dataset=self.dataset,
            parallel_cores=self.parallel_cores,
        )


def load_generation_config(path: Union[str, Path]) -> GenerationConfig:
    """Load the configuration from a YAML or JSON file."""

    config_path = Path(path)
    if not config_path.exists():
        raise FileNotFoundError(f"Configuration file not found: {config_path}")

    try:
        text = config_path.read_text()
    except OSError as exc:  # pragma: no cover - filesystem guard
        raise ConfigurationError(f"Failed to read configuration file: {config_path}") from exc

    suffix = config_path.suffix.lower()
    if suffix in {".yaml", ".yml"}:
        data = yaml.safe_load(text)
    elif suffix == ".json":
        data = json.loads(text)
    else:
        raise ConfigurationError("Configuration file must be in YAML or JSON format")

    if not isinstance(data, Mapping):
        raise ConfigurationError("Top-level configuration must be a mapping")

    base_path = config_path.parent.resolve()
    return GenerationConfig.from_mapping(data, base_path=base_path)


def _parse_topologies(
    raw_topologies: Optional[Any],
    taxa_labels: tuple[str, ...],
    *,
    rooted: bool,
) -> tuple[TopologySpec, ...]:
    if raw_topologies is None:
        raise ConfigurationError("'tree.topologies' is now a required field")

    if isinstance(raw_topologies, (str, bytes)):
        items = [raw_topologies]
    else:
        if not isinstance(raw_topologies, Iterable):
            raise ConfigurationError("'tree.topologies' must be an iterable of strings")
        items = list(raw_topologies)

    if not items:
        raise ConfigurationError("'tree.topologies' must contain at least one entry")

    parsed: list[TopologySpec] = []
    seen_signatures: set[TopologySpec] = set()
    for entry in items:
        topology = _parse_topology_entry(entry, taxa_labels, rooted=rooted)
        if topology in seen_signatures:
            continue
        seen_signatures.add(topology)
        parsed.append(topology)

    if not parsed:
        raise ConfigurationError("'tree.topologies' must contain at least one unique definition")

    return tuple(parsed)


def _parse_topology_entry(
    entry: Any,
    taxa_labels: tuple[str, ...],
    *,
    rooted: bool,
) -> TopologySpec:
    if not isinstance(entry, str):
        raise ConfigurationError("Each entry in 'tree.topologies' must be a string")
    normalized = entry.strip().rstrip(";").strip()
    if not normalized:
        raise ConfigurationError("Topology strings must be non-empty")

    taxa_set = set(taxa_labels)

    if rooted:
        left_expr, right_expr, left_marked, right_marked = _extract_root_children(normalized)
        if left_marked == right_marked:
            raise ConfigurationError("Rooted trees must mark exactly one child with ':'")
        if left_marked:
            left_expr, right_expr = right_expr, left_expr

        _reject_internal_root_marker(left_expr)
        _reject_internal_root_marker(right_expr)

        left_node = _parse_newick_subtree(left_expr, taxa_set)
        right_node = _parse_newick_subtree(right_expr, taxa_set)
        left_groups = _subtree_to_groups(left_node)
        right_groups = _subtree_to_groups(right_node)
        if not left_groups or not right_groups:
            raise ConfigurationError("Topology definitions must include taxa on both sides of ':'")

        tokens: tuple[tuple[str, ...], ...] = tuple(left_groups + right_groups)
        root_index = len(left_groups) - 1
    else:
        if ":" in normalized:
            warnings.warn(
                f"Ignoring ':' markers in unrooted topology '{entry}'",
                RuntimeWarning,
            )
            normalized = normalized.replace(":", "")
        node = _parse_newick_subtree(normalized, taxa_set)
        tokens = tuple(_subtree_to_groups(node))
        root_index = None

    return _finalize_topology(tokens, root_index, entry, taxa_set)


def _expect_mapping(payload: Mapping[str, Any], key: str) -> Mapping[str, Any]:
    try:
        value = payload[key]
    except KeyError as exc:
        raise ConfigurationError(f"Configuration missing required key: '{key}'") from exc
    if not isinstance(value, Mapping):
        raise ConfigurationError(f"Configuration value for '{key}' must be a mapping")
    return value


def _expect_iterable(payload: Mapping[str, Any], key: str) -> Sequence[Any]:
    value = payload.get(key)
    if value is None:
        raise ConfigurationError(f"Configuration missing required key: '{key}'")
    if isinstance(value, (str, bytes)):
        raise ConfigurationError(f"Configuration value for '{key}' must not be a string")
    if not isinstance(value, Iterable):
        raise ConfigurationError(f"Configuration value for '{key}' must be iterable")
    return list(value)


def _resolve_data_root(base_path: Optional[Path]) -> Path:
    if base_path is None:
        return Path.cwd()

    candidates = []
    candidates.append(base_path)
    candidates.append(base_path.parent)

    for candidate in candidates:
        xml_candidate = candidate / "xml_data"
        npy_candidate = candidate / "npy_data"
        if xml_candidate.exists() or npy_candidate.exists():
            return candidate

    if base_path.name.lower() == "config":
        return base_path.parent

    return base_path


def _find_duplicate_taxa(flattened: Sequence[str]) -> tuple[str, ...]:
    counts = Counter(flattened)
    duplicates = tuple(sorted({taxon for taxon, count in counts.items() if count > 1}))
    return duplicates


@dataclass(frozen=True)
class _TopologyNode:
    label: str | None = None
    left: "_TopologyNode" | None = None
    right: "_TopologyNode" | None = None

    @property
    def is_leaf(self) -> bool:
        return self.label is not None


def _extract_root_children(expr: str) -> tuple[str, str, bool, bool]:
    expr = expr.strip()
    if not (expr.startswith("(") and expr.endswith(")")):
        raise ConfigurationError("Rooted topology definitions must start and end with parentheses")

    inner = expr[1:-1].strip()
    parts = _split_top_level(inner)
    if len(parts) != 2:
        raise ConfigurationError("Rooted topology definitions must describe exactly two child subtrees")

    left_raw = parts[0].strip()
    right_raw = parts[1].strip()
    left_marked = left_raw.startswith(":")
    right_marked = right_raw.startswith(":")
    left_expr = left_raw[1:].strip() if left_marked else left_raw
    right_expr = right_raw[1:].strip() if right_marked else right_raw
    if not left_expr or not right_expr:
        raise ConfigurationError("Topology definitions must contain taxa on both sides of ':'")

    return left_expr, right_expr, left_marked, right_marked


def _reject_internal_root_marker(expr: str) -> None:
    if ":" in expr:
        raise ConfigurationError(": markers are only allowed immediately before the root split")


def _split_top_level(expr: str) -> list[str]:
    parts: list[str] = []
    depth = 0
    start = 0
    for index, char in enumerate(expr):
        if char == "(":
            depth += 1
        elif char == ")":
            if depth == 0:
                raise ConfigurationError("Unbalanced parentheses in topology definition")
            depth -= 1
        elif char == "," and depth == 0:
            parts.append(expr[start:index])
            start = index + 1
    if depth != 0:
        raise ConfigurationError("Unbalanced parentheses in topology definition")
    parts.append(expr[start:])
    return parts


def _parse_newick_subtree(expr: str, taxa_set: set[str]) -> _TopologyNode:
    expr = expr.strip()
    if not expr:
        raise ConfigurationError("Topology subtrees must be non-empty")
    if ":" in expr:
        raise ConfigurationError(": markers are only allowed at the root split")

    if expr.startswith("("):
        if not expr.endswith(")"):
            raise ConfigurationError("Unbalanced parentheses in topology definition")
        inner = expr[1:-1].strip()
        parts = _split_top_level(inner)
        if len(parts) != 2:
            raise ConfigurationError("Topology definitions must describe binary trees")
        left = _parse_newick_subtree(parts[0], taxa_set)
        right = _parse_newick_subtree(parts[1], taxa_set)
        return _TopologyNode(left=left, right=right)

    if expr not in taxa_set:
        raise ConfigurationError(f"Topology references unknown taxon '{expr}'")
    return _TopologyNode(label=expr)


def _subtree_to_groups(node: _TopologyNode) -> list[tuple[str, ...]]:
    if node.is_leaf:
        assert node.label is not None  # for type checkers
        return [(node.label,)]

    if _is_simple_subtree(node):
        return [_collect_simple_group(node)]

    simple_child, remainder = _detach_simple_child(node)
    group = _collect_simple_group(simple_child)
    tail = _subtree_to_groups(remainder)
    return [group] + tail


def _detach_simple_child(node: _TopologyNode) -> tuple[_TopologyNode, _TopologyNode]:
    if node.left is None or node.right is None:
        raise ConfigurationError("Internal topology nodes must have two children")
    if _is_simple_subtree(node.left):
        return node.left, node.right
    if _is_simple_subtree(node.right):
        return node.right, node.left
    raise ConfigurationError(
        "Each split must include either a single taxon or a cherry (two taxa) alongside the remaining subtree"
    )


def _is_simple_subtree(node: _TopologyNode | None) -> bool:
    if node is None:
        return False
    if node.is_leaf:
        return True
    return (
        node.left is not None
        and node.right is not None
        and node.left.is_leaf
        and node.right.is_leaf
    )


def _collect_simple_group(node: _TopologyNode) -> tuple[str, ...]:
    if node.is_leaf and node.label is not None:
        return (node.label,)
    if (
        node.left is not None
        and node.right is not None
        and node.left.label is not None
        and node.right.label is not None
    ):
        return (node.left.label, node.right.label)
    raise ConfigurationError("Topology groups may only contain one or two taxa")


def _finalize_topology(
    tokens: Sequence[tuple[str, ...]],
    root_index: int | None,
    original: str,
    taxa_set: set[str],
) -> TopologySpec:
    if not tokens:
        raise ConfigurationError("Topology definitions must reference at least one group")

    flattened = tuple(taxon for group in tokens for taxon in group)
    duplicates = _find_duplicate_taxa(flattened)
    if duplicates:
        raise ConfigurationError(
            f"Duplicate taxa found in topology '{original}': " + ", ".join(sorted(duplicates))
        )

    seen = set(flattened)
    if seen != taxa_set:
        missing = taxa_set - seen
        raise ConfigurationError(
            "Each topology must reference all taxa exactly once; missing: " + ", ".join(sorted(missing))
        )

    return TopologySpec(tokens=tuple(tokens), root_index=root_index)
